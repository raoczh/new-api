# New API 快速开发指南

## 目录

1. [环境搭建](#环境搭建)
2. [后端开发](#后端开发)
3. [前端开发](#前端开发)
4. [常见开发任务](#常见开发任务)
5. [调试技巧](#调试技巧)
6. [部署指南](#部署指南)

## 环境搭建

### 1. 系统要求

- **Go**: 1.22+
- **Node.js**: 18+ (推荐使用 Bun)
- **数据库**: SQLite (默认) / MySQL 5.7.8+ / PostgreSQL 9.6+
- **Redis**: 可选，用于分布式部署

### 2. 克隆项目

```bash
git clone https://github.com/Calcium-Ion/new-api.git
cd new-api
```

### 3. 后端环境配置

```bash
# 安装 Go 依赖
go mod download

# 创建 .env 文件
cp .env.example .env

# 编辑 .env 配置
vim .env
```

**.env 配置示例**:

```bash
# 数据库配置
SQL_DSN=local  # SQLite (默认)
# SQL_DSN=user:pass@tcp(localhost:3306)/newapi?parseTime=true  # MySQL
# SQL_DSN=postgres://user:pass@localhost:5432/newapi  # PostgreSQL

# Redis 配置 (可选)
# REDIS_CONN_STRING=redis://localhost:6379

# 服务器配置
PORT=3001
SESSION_SECRET=random_string_here

# 日志配置
LOG_DIR=./logs

# 调试模式
DEBUG=false
```

### 4. 前端环境配置

```bash
cd web

# 使用 Bun (推荐)
bun install

# 或使用 npm
npm install
```

### 5. 启动开发环境

**后端**:

```bash
# 在项目根目录
go run main.go
```

**前端**:

```bash
# 在 web 目录
bun run dev

# 或
npm run dev
```

访问 http://localhost:3001

## 后端开发

### 1. 添加新的 API 端点

#### 步骤 1: 定义路由

```go
// router/api-router.go
func SetApiRouter(router *gin.Engine) {
    apiRouter := router.Group("/api")

    // 添加新路由
    apiRouter.GET("/my-endpoint", controller.MyEndpoint)
    apiRouter.POST("/my-endpoint", middleware.UserAuth(), controller.CreateMyResource)
}
```

#### 步骤 2: 创建控制器

```go
// controller/my_controller.go
package controller

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/QuantumNous/new-api/model"
)

func MyEndpoint(c *gin.Context) {
    // 获取查询参数
    param := c.Query("param")

    // 调用服务层
    result, err := service.MyService(param)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "message": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": result,
    })
}

func CreateMyResource(c *gin.Context) {
    // 获取用户ID
    userId := c.GetInt("id")

    // 解析请求体
    var req dto.MyRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "message": "无效的请求",
        })
        return
    }

    // 调用服务层
    err := service.CreateMyResource(userId, &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "message": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "message": "创建成功",
    })
}
```

#### 步骤 3: 创建服务层

```go
// service/my_service.go
package service

import (
    "github.com/QuantumNous/new-api/model"
    "github.com/QuantumNous/new-api/dto"
)

func MyService(param string) (interface{}, error) {
    // 业务逻辑
    data, err := model.GetMyData(param)
    if err != nil {
        return nil, err
    }

    // 数据处理
    result := processData(data)

    return result, nil
}

func CreateMyResource(userId int, req *dto.MyRequest) error {
    // 验证
    if err := validateRequest(req); err != nil {
        return err
    }

    // 创建资源
    resource := &model.MyResource{
        UserId: userId,
        Name:   req.Name,
        Value:  req.Value,
    }

    return model.CreateMyResource(resource)
}
```

#### 步骤 4: 创建数据模型

```go
// model/my_resource.go
package model

import "gorm.io/gorm"

type MyResource struct {
    Id        int    `json:"id"`
    UserId    int    `json:"user_id" gorm:"index"`
    Name      string `json:"name"`
    Value     string `json:"value"`
    CreatedAt int64  `json:"created_at" gorm:"bigint"`
}

func CreateMyResource(resource *MyResource) error {
    return DB.Create(resource).Error
}

func GetMyResourceById(id int) (*MyResource, error) {
    var resource MyResource
    err := DB.First(&resource, id).Error
    return &resource, err
}

func GetMyResourcesByUserId(userId int) ([]*MyResource, error) {
    var resources []*MyResource
    err := DB.Where("user_id = ?", userId).Find(&resources).Error
    return resources, err
}

func UpdateMyResource(resource *MyResource) error {
    return DB.Save(resource).Error
}

func DeleteMyResource(id int) error {
    return DB.Delete(&MyResource{}, id).Error
}
```

### 2. 添加新的 AI 提供商适配器

#### 步骤 1: 创建适配器目录

```bash
mkdir relay/channel/myprovider
```

#### 步骤 2: 实现适配器接口

```go
// relay/channel/myprovider/adaptor.go
package myprovider

import (
    "io"
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/QuantumNous/new-api/dto"
    "github.com/QuantumNous/new-api/relay/channel"
    relaycommon "github.com/QuantumNous/new-api/relay/common"
    "github.com/QuantumNous/new-api/types"
)

type Adaptor struct {
    channel.BaseAdaptor
}

func (a *Adaptor) Init(info *relaycommon.RelayInfo) {
    a.BaseAdaptor.Init(info)
}

func (a *Adaptor) GetRequestURL(info *relaycommon.RelayInfo) (string, error) {
    // 构建请求 URL
    return info.BaseURL + "/v1/chat/completions", nil
}

func (a *Adaptor) GetRequestHeaders() http.Header {
    headers := make(http.Header)
    headers.Set("Authorization", "Bearer "+a.ApiKey)
    headers.Set("Content-Type", "application/json")
    return headers
}

func (a *Adaptor) ConvertRequest(c *gin.Context, relayMode int, request *dto.GeneralOpenAIRequest) (any, error) {
    // 转换请求格式
    myRequest := &MyProviderRequest{
        Model:    request.Model,
        Messages: convertMessages(request.Messages),
        Stream:   request.Stream,
    }
    return myRequest, nil
}

func (a *Adaptor) DoRequest(c *gin.Context, info *relaycommon.RelayInfo, requestBody io.Reader) (*http.Response, error) {
    // 发送请求
    return a.BaseAdaptor.DoRequest(c, info, requestBody)
}

func (a *Adaptor) DoResponse(c *gin.Context, resp *http.Response, info *relaycommon.RelayInfo) (usage *dto.Usage, err *types.OpenAIErrorWithStatusCode) {
    if info.IsStream {
        return a.handleStreamResponse(c, resp, info)
    }
    return a.handleNonStreamResponse(c, resp, info)
}

func (a *Adaptor) GetModelList() []string {
    return []string{
        "my-model-1",
        "my-model-2",
    }
}

func (a *Adaptor) GetChannelName() string {
    return "MyProvider"
}
```

#### 步骤 3: 注册适配器

```go
// constant/channel.go
const (
    // ... 现有常量
    ChannelTypeMyProvider = 100  // 添加新的渠道类型
)

// relay/channel/adaptor.go
func GetAdaptor(channelType int) channel.Adaptor {
    switch channelType {
    // ... 现有 case
    case constant.ChannelTypeMyProvider:
        return &myprovider.Adaptor{}
    default:
        return nil
    }
}
```

### 3. 添加中间件

```go
// middleware/my_middleware.go
package middleware

import (
    "github.com/gin-gonic/gin"
    "github.com/QuantumNous/new-api/common"
)

func MyMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 前置处理
        common.SysLog("MyMiddleware: before request")

        // 继续处理请求
        c.Next()

        // 后置处理
        common.SysLog("MyMiddleware: after request")
    }
}

// 在 router/main.go 中注册
func SetRouter(router *gin.Engine, buildFS embed.FS, indexPage []byte) {
    router.Use(middleware.MyMiddleware())
    // ...
}
```

## 前端开发

### 1. 创建新页面

#### 步骤 1: 创建页面组件

```jsx
// web/src/pages/MyPage.jsx
import React, { useState, useEffect } from "react";
import { Card, Button, Table, Toast } from "@douyinfe/semi-ui";
import { useTranslation } from "react-i18next";
import API from "../service/api";

function MyPage() {
  const { t } = useTranslation();
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    setLoading(true);
    try {
      const res = await API.get("/api/my-endpoint");
      setData(res.data.data);
    } catch (error) {
      Toast.error(t("加载失败"));
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      title: "ID",
      dataIndex: "id",
    },
    {
      title: t("名称"),
      dataIndex: "name",
    },
    {
      title: t("操作"),
      render: (_, record) => (
        <Button onClick={() => handleEdit(record)}>{t("编辑")}</Button>
      ),
    },
  ];

  return (
    <div>
      <Card title={t("我的页面")}>
        <Button onClick={loadData}>{t("刷新")}</Button>
        <Table columns={columns} dataSource={data} loading={loading} />
      </Card>
    </div>
  );
}

export default MyPage;
```

#### 步骤 2: 添加路由

```jsx
// web/src/App.jsx
import MyPage from "./pages/MyPage";

function App() {
  return (
    <Routes>
      {/* 现有路由 */}
      <Route
        path="/console/mypage"
        element={
          <PrivateRoute>
            <MyPage />
          </PrivateRoute>
        }
      />
    </Routes>
  );
}
```

#### 步骤 3: 添加侧边栏菜单

```jsx
// web/src/components/layout/SiderBar.jsx
const menuItems = [
  // ... 现有菜单
  {
    itemKey: "mypage",
    text: t("我的页面"),
    icon: <IconSetting />,
    path: "/console/mypage",
  },
];
```

### 2. 创建表格组件

```jsx
// web/src/components/table/my-table/MyTable.jsx
import React, { useState, useEffect } from "react";
import { Table, Button, Space, Toast } from "@douyinfe/semi-ui";
import { useTranslation } from "react-i18next";
import API from "../../../service/api";
import MyTableActions from "./MyTableActions";
import MyTableFilters from "./MyTableFilters";
import EditModal from "./modals/EditModal";

function MyTable() {
  const { t } = useTranslation();
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({
    currentPage: 1,
    pageSize: 10,
    total: 0,
  });
  const [filters, setFilters] = useState({});
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [currentRecord, setCurrentRecord] = useState(null);

  useEffect(() => {
    loadData();
  }, [pagination.currentPage, pagination.pageSize, filters]);

  const loadData = async () => {
    setLoading(true);
    try {
      const res = await API.get("/api/my-endpoint", {
        params: {
          page: pagination.currentPage - 1,
          size: pagination.pageSize,
          ...filters,
        },
      });
      setData(res.data.data);
      setPagination({
        ...pagination,
        total: res.data.total,
      });
    } catch (error) {
      Toast.error(t("加载失败"));
    } finally {
      setLoading(false);
    }
  };

  const handleEdit = (record) => {
    setCurrentRecord(record);
    setEditModalVisible(true);
  };

  const handleDelete = async (record) => {
    try {
      await API.delete(`/api/my-endpoint/${record.id}`);
      Toast.success(t("删除成功"));
      loadData();
    } catch (error) {
      Toast.error(t("删除失败"));
    }
  };

  const columns = [
    {
      title: "ID",
      dataIndex: "id",
      width: 80,
    },
    {
      title: t("名称"),
      dataIndex: "name",
    },
    {
      title: t("操作"),
      render: (_, record) => (
        <Space>
          <Button onClick={() => handleEdit(record)}>{t("编辑")}</Button>
          <Button type="danger" onClick={() => handleDelete(record)}>
            {t("删除")}
          </Button>
        </Space>
      ),
    },
  ];

  return (
    <div>
      <MyTableActions onRefresh={loadData} />
      <MyTableFilters filters={filters} onChange={setFilters} />
      <Table
        columns={columns}
        dataSource={data}
        loading={loading}
        pagination={{
          currentPage: pagination.currentPage,
          pageSize: pagination.pageSize,
          total: pagination.total,
          onPageChange: (page) =>
            setPagination({ ...pagination, currentPage: page }),
        }}
      />
      <EditModal
        visible={editModalVisible}
        record={currentRecord}
        onClose={() => setEditModalVisible(false)}
        onSuccess={loadData}
      />
    </div>
  );
}

export default MyTable;
```

### 3. 添加 API 服务

```jsx
// web/src/service/api.js
const API = {
  // ... 现有 API

  // 我的资源相关
  getMyResources: (params) => request.get("/api/my-endpoint", { params }),
  getMyResource: (id) => request.get(`/api/my-endpoint/${id}`),
  createMyResource: (data) => request.post("/api/my-endpoint", data),
  updateMyResource: (id, data) => request.put(`/api/my-endpoint/${id}`, data),
  deleteMyResource: (id) => request.delete(`/api/my-endpoint/${id}`),
};
```

## 常见开发任务

### 1. 添加新的系统配置项

#### 后端:

```go
// model/option.go
const (
    // ... 现有常量
    KeyMyNewOption = "MyNewOption"
)

// 在 InitOptionMap 中添加默认值
func InitOptionMap() {
    // ...
    OptionMap[KeyMyNewOption] = "default_value"
}
```

#### 前端:

```jsx
// web/src/components/settings/SystemSetting.jsx
const [myNewOption, setMyNewOption] = useState("");

useEffect(() => {
  loadOptions();
}, []);

const loadOptions = async () => {
  const res = await API.get("/api/option/");
  setMyNewOption(res.data.MyNewOption || "");
};

const saveOption = async () => {
  await API.put("/api/option/", {
    key: "MyNewOption",
    value: myNewOption,
  });
  Toast.success("保存成功");
};

return (
  <Form.Input
    label="我的新配置"
    value={myNewOption}
    onChange={setMyNewOption}
  />
);
```

### 2. 添加新的用户角色

```go
// common/constants.go
const (
    RoleGuestUser  = 0
    RoleCommonUser = 1
    RoleAdminUser  = 10
    RoleRootUser   = 100
    RoleMyNewRole  = 50  // 添加新角色
)

// middleware/auth.go
func MyRoleAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        role := c.GetInt("role")
        if role < RoleMyNewRole {
            c.JSON(http.StatusForbidden, gin.H{
                "success": false,
                "message": "权限不足",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}
```

### 3. 添加新的模型定价

```go
// model/pricing.go
func InitDefaultPricing() {
    pricingMap := map[string]*ModelPricing{
        // ... 现有定价
        "my-new-model": {
            InputPrice:  0.001,  // 每百万 Token
            OutputPrice: 0.002,
            Unit:        "1M tokens",
        },
    }
}
```

## 调试技巧

### 1. 后端调试

#### 启用调试模式:

```bash
# .env
DEBUG=true
```

#### 使用日志:

```go
import "github.com/QuantumNous/new-api/common"

// 系统日志
common.SysLog("This is a system log")

// 错误日志
common.SysError("This is an error log")

// 调试日志 (仅在 DEBUG=true 时输出)
if common.DebugEnabled {
    common.SysLog(fmt.Sprintf("Debug info: %+v", data))
}
```

#### 使用 pprof 性能分析:

```bash
# .env
ENABLE_PPROF=true

# 访问性能分析页面
http://localhost:8005/debug/pprof/
```

### 2. 前端调试

#### 使用 React DevTools:

安装 Chrome 扩展: React Developer Tools

#### 使用 Console:

```jsx
console.log("Debug info:", data);
console.error("Error:", error);
console.table(arrayData);
```

#### 网络请求调试:

```jsx
// service/request.js
request.interceptors.request.use((config) => {
  console.log("Request:", config);
  return config;
});

request.interceptors.response.use((response) => {
  console.log("Response:", response);
  return response;
});
```

### 3. 数据库调试

#### 查看 SQL 日志:

```go
// main.go
if common.DebugEnabled {
    db = db.Debug()  // 输出所有 SQL 语句
}
```

#### 使用数据库客户端:

- SQLite: DB Browser for SQLite
- MySQL: MySQL Workbench
- PostgreSQL: pgAdmin

## 部署指南

### 1. 编译项目

```bash
# 后端编译
go build -o new-api main.go

# 前端编译
cd web
bun run build
cd ..
```

### 2. Docker 部署

```dockerfile
# Dockerfile
FROM golang:1.22-alpine AS backend-builder
WORKDIR /app
COPY . .
RUN go build -o new-api main.go

FROM node:18-alpine AS frontend-builder
WORKDIR /app/web
COPY web/package.json web/bun.lockb ./
RUN npm install -g bun && bun install
COPY web/ ./
RUN bun run build

FROM alpine:latest
WORKDIR /app
COPY --from=backend-builder /app/new-api .
COPY --from=frontend-builder /app/web/dist ./web/dist
EXPOSE 3000
CMD ["./new-api"]
```

```bash
# 构建镜像
docker build -t new-api:latest .

# 运行容器
docker run -d \
  -p 3000:3000 \
  -v $(pwd)/data:/app/data \
  -e SQL_DSN=local \
  --name new-api \
  new-api:latest
```

### 3. Docker Compose 部署

```yaml
# docker-compose.yml
version: "3"

services:
  new-api:
    image: new-api:latest
    ports:
      - "3000:3000"
    environment:
      - SQL_DSN=postgres://user:pass@postgres:5432/newapi
      - REDIS_CONN_STRING=redis://redis:6379
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data:/app/data

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=newapi
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

```bash
# 启动服务
docker-compose up -d

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down
```

### 4. 生产环境配置

```bash
# .env.production
SQL_DSN=postgres://user:pass@db-host:5432/newapi
REDIS_CONN_STRING=redis://redis-host:6379
SESSION_SECRET=your-secret-key-here
PORT=3001
GIN_MODE=release
DEBUG=false

# 日志配置
LOG_DIR=/var/log/new-api

# 性能配置
SQL_MAX_IDLE_CONNS=100
SQL_MAX_OPEN_CONNS=1000
SQL_MAX_LIFETIME=60

# 批量更新
BATCH_UPDATE_ENABLED=true
BATCH_UPDATE_INTERVAL=5
```

### 5. Nginx 反向代理

```nginx
# /etc/nginx/sites-available/new-api
server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://localhost:3001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket 支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
```

### 6. 系统服务配置

```ini
# /etc/systemd/system/new-api.service
[Unit]
Description=New API Service
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/new-api
ExecStart=/opt/new-api/new-api
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

```bash
# 启动服务
sudo systemctl start new-api

# 开机自启
sudo systemctl enable new-api

# 查看状态
sudo systemctl status new-api

# 查看日志
sudo journalctl -u new-api -f
```

## 下一步

- 阅读 [01-后端架构总览.md](./01-后端架构总览.md) 了解后端架构
- 阅读 [04-前端架构总览.md](./04-前端架构总览.md) 了解前端架构
- 阅读 [05-完整工作原理.md](./05-完整工作原理.md) 了解系统工作流程
- 查看项目 Issues 和 Pull Requests 了解最新开发动态
