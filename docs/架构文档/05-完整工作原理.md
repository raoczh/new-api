# New API 完整工作原理

## 系统概述

New API 是一个 AI API 网关系统，作为客户端和多个 AI 提供商之间的中间层，提供统一的 API 接口、用户管理、计费、监控等功能。

## 完整请求流程

### 1. 客户端发起请求

```
客户端 → POST /v1/chat/completions
Headers:
  Authorization: Bearer sk-xxxxx
Body:
  {
    "model": "gpt-4",
    "messages": [{"role": "user", "content": "Hello"}],
    "stream": true
  }
```

### 2. 请求处理流程图

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Gin Router 接收请求                                       │
│    - 路由匹配: /v1/chat/completions                          │
│    - 识别中继模式: RelayModeChatCompletions                  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Middleware 中间件链                                       │
│    ├── RequestId: 生成请求ID                                 │
│    ├── PoweredBy: 添加响应头                                 │
│    ├── I18n: 国际化处理                                      │
│    ├── Logger: 记录请求日志                                  │
│    ├── CORS: 跨域处理                                        │
│    └── Session: 会话管理                                     │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Auth Middleware 认证                                      │
│    ├── 提取 Authorization 头                                 │
│    ├── 验证令牌有效性                                        │
│    ├── 检查令牌状态（启用/禁用）                             │
│    ├── 检查令牌过期时间                                      │
│    ├── 检查 IP 白名单                                        │
│    ├── 加载用户信息                                          │
│    └── 设置上下文: user_id, token_id, user_group             │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Rate Limit Middleware 速率限制                            │
│    ├── 检查全局速率限制                                      │
│    ├── 检查用户级速率限制                                    │
│    ├── 检查模型级速率限制                                    │
│    └── 如果超限，返回 429 Too Many Requests                  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Distributor Middleware 渠道分发                           │
│    ├── 解析请求模型: "gpt-4"                                 │
│    ├── 检查令牌模型限制                                      │
│    │   └── 如果令牌不允许访问该模型，返回 403                │
│    ├── 检查渠道亲和性                                        │
│    │   └── 优先使用最近成功的渠道                            │
│    ├── 随机选择可用渠道                                      │
│    │   ├── 过滤: 分组匹配                                    │
│    │   ├── 过滤: 模型支持                                    │
│    │   ├── 过滤: 渠道状态（启用）                            │
│    │   ├── 排序: 按权重和优先级                              │
│    │   └── 加权随机选择                                      │
│    └── 设置渠道上下文                                        │
│        ├── channel_id, channel_name, channel_type            │
│        ├── channel_key (API密钥)                             │
│        ├── channel_base_url                                  │
│        ├── channel_model_mapping (模型映射)                  │
│        ├── channel_param_override (参数覆盖)                 │
│        └── channel_header_override (请求头覆盖)              │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. Relay Controller 中继控制器                               │
│    ├── 创建计费会话                                          │
│    │   └── 记录: user_id, token_id, channel_id, model       │
│    ├── 获取渠道适配器                                        │
│    │   └── 根据 channel_type 选择适配器                      │
│    └── 调用适配器处理请求                                    │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. Channel Adaptor 渠道适配器                                │
│    ├── 初始化适配器                                          │
│    ├── 请求格式转换                                          │
│    │   ├── 应用模型映射                                      │
│    │   │   └── "gpt-4" → "gpt-4-0613" (如果配置了映射)       │
│    │   ├── 应用参数覆盖                                      │
│    │   │   └── 覆盖 temperature, max_tokens 等               │
│    │   └── 格式转换                                          │
│    │       ├── OpenAI → OpenAI (无需转换)                    │
│    │       ├── OpenAI → Claude (转换消息格式)                │
│    │       └── OpenAI → Gemini (转换内容格式)                │
│    ├── 构建 HTTP 请求                                        │
│    │   ├── URL: channel_base_url + path                      │
│    │   ├── Headers:                                          │
│    │   │   ├── Authorization: Bearer {channel_key}           │
│    │   │   ├── Content-Type: application/json                │
│    │   │   └── 应用 header_override                          │
│    │   └── Body: 转换后的请求体                              │
│    └── 发送请求到上游 AI 提供商                              │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. 上游 AI 提供商处理                                        │
│    └── OpenAI / Claude / Gemini / ... 处理请求               │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 9. 响应处理                                                  │
│    ├── 接收上游响应                                          │
│    ├── 检查响应状态码                                        │
│    │   ├── 2xx: 成功                                         │
│    │   ├── 4xx: 客户端错误                                   │
│    │   └── 5xx: 服务器错误 (可能重试)                        │
│    ├── 应用状态码映射                                        │
│    │   └── 将上游错误码映射为标准错误码                      │
│    └── 响应格式转换                                          │
│        ├── Claude → OpenAI                                   │
│        ├── Gemini → OpenAI                                   │
│        └── OpenAI → OpenAI (无需转换)                        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 10. 流式响应处理 (如果 stream=true)                          │
│     ├── 设置 SSE 响应头                                      │
│     │   ├── Content-Type: text/event-stream                  │
│     │   ├── Cache-Control: no-cache                          │
│     │   └── Connection: keep-alive                           │
│     ├── 逐块读取上游响应                                     │
│     ├── 解析每个 SSE 事件                                    │
│     │   └── data: {...}                                      │
│     ├── 提取 Token 使用信息                                  │
│     │   ├── prompt_tokens                                    │
│     │   ├── completion_tokens                                │
│     │   └── total_tokens                                     │
│     ├── 转发给客户端                                         │
│     │   └── c.SSEvent("", data)                              │
│     └── 检测结束标记                                         │
│         └── data: [DONE]                                     │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 11. Token 计数                                               │
│     ├── 如果响应包含 usage 信息                              │
│     │   └── 直接使用 prompt_tokens, completion_tokens        │
│     ├── 否则，使用 tiktoken 计算                             │
│     │   ├── 计算输入 Token 数                                │
│     │   │   └── 遍历 messages，编码每条消息                  │
│     │   └── 计算输出 Token 数                                │
│     │       └── 编码响应内容                                 │
│     └── 更新计费会话                                         │
│         ├── prompt_tokens                                    │
│         ├── completion_tokens                                │
│         └── total_tokens                                     │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 12. 计费处理                                                 │
│     ├── 获取模型定价                                         │
│     │   ├── input_price (每百万 Token)                       │
│     │   └── output_price (每百万 Token)                      │
│     ├── 计算配额消耗                                         │
│     │   ├── input_cost = prompt_tokens * input_price / 1M    │
│     │   ├── output_cost = completion_tokens * output_price/1M│
│     │   ├── total_cost = input_cost + output_cost            │
│     │   └── quota = total_cost * quota_per_unit              │
│     ├── 扣除用户配额                                         │
│     │   └── user.quota -= quota                              │
│     ├── 扣除令牌配额 (如果不是无限配额)                      │
│     │   └── token.remain_quota -= quota                      │
│     ├── 增加渠道使用量                                       │
│     │   └── channel.used_quota += quota                      │
│     └── 更新统计数据                                         │
│         ├── user.used_quota += quota                         │
│         ├── user.request_count += 1                          │
│         └── token.used_quota += quota                        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 13. 日志记录                                                 │
│     ├── 创建日志记录                                         │
│     │   ├── user_id, username                                │
│     │   ├── token_id, token_name                             │
│     │   ├── channel_id, channel_name                         │
│     │   ├── model_name                                       │
│     │   ├── prompt_tokens, completion_tokens                 │
│     │   ├── quota                                            │
│     │   ├── request_id                                       │
│     │   ├── use_time (响应时间)                              │
│     │   └── group                                            │
│     ├── 写入日志数据库                                       │
│     │   └── 可能是独立的日志数据库 (LOG_SQL_DSN)            │
│     └── 批量写入 (如果启用批量更新)                          │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 14. 渠道亲和性记录                                           │
│     ├── 如果请求成功 (状态码 < 400)                          │
│     ├── 记录用户对该渠道的亲和性                             │
│     │   └── Redis: affinity:{user_id}:{group}:{model}        │
│     │       = channel_id (TTL: 1小时)                        │
│     └── 下次请求时优先使用此渠道                             │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 15. 返回响应给客户端                                         │
│     └── 流式: SSE 流                                         │
│         或                                                   │
│         非流式: JSON 响应                                    │
└─────────────────────────────────────────────────────────────┘
```

## 错误处理和重试

### 1. 错误处理流程

```
请求失败
    ↓
检查错误类型
    ├── 认证错误 (401, 403)
    │   ├── 立即禁用渠道 (如果启用自动禁用)
    │   └── 返回错误给客户端
    │
    ├── 速率限制 (429)
    │   ├── 标记为可重试错误
    │   └── 进入重试流程
    │
    ├── 服务器错误 (500, 502, 503, 504)
    │   ├── 标记为可重试错误
    │   └── 进入重试流程
    │
    └── 其他错误 (400, 404等)
        └── 返回错误给客户端
```

### 2. 重试流程

```
重试流程 (最多3次)
    ↓
记录失败的渠道ID
    ↓
重新选择渠道
    ├── 排除已失败的渠道
    ├── 按权重和优先级排序
    └── 随机选择新渠道
    ↓
如果找到新渠道
    ├── 设置新渠道上下文
    └── 重新发送请求
    ↓
如果没有可用渠道
    └── 返回错误给客户端
```

## 缓存系统

### 1. 渠道缓存

```
启动时
    ↓
InitChannelCache()
    ├── 从数据库加载所有渠道
    ├── 解析渠道配置
    │   ├── 模型列表
    │   ├── 模型映射
    │   ├── 参数覆盖
    │   └── 多Key配置
    ├── 构建缓存索引
    │   ├── 按分组索引: group → channels
    │   ├── 按模型索引: model → channels
    │   └── 按分组+模型索引: group:model → channels
    └── 存储到内存缓存
    ↓
定期同步 (默认60秒)
    ├── 重新加载数据库
    ├── 更新内存缓存
    └── 如果启用Redis，同步到Redis
```

### 2. 配置缓存

```
启动时
    ↓
InitOptionMap()
    ├── 从数据库加载所有配置
    ├── 解析配置值 (JSON)
    └── 存储到内存 Map
    ↓
定期同步 (默认60秒)
    ├── 重新加载数据库
    └── 更新内存 Map
```

### 3. Redis 缓存 (可选)

```
如果启用 Redis
    ├── 渠道亲和性缓存
    │   └── affinity:{user_id}:{group}:{model} = channel_id
    ├── 速率限制计数器
    │   └── rate_limit:{user_id}:{window} = count
    └── 分布式锁
        └── lock:{resource} = lock_id
```

## 监控和统计

### 1. 实时监控

```
每次请求完成后
    ↓
更新渠道响应时间
    ├── channel.response_time = 本次响应时间
    └── 用于渠道健康度评估
    ↓
更新渠道使用量
    ├── channel.used_quota += quota
    └── 用于成本统计
    ↓
更新用户统计
    ├── user.used_quota += quota
    ├── user.request_count += 1
    └── 用于用户分析
```

### 2. 配额数据统计

```
定期任务 (每小时)
    ↓
UpdateQuotaData()
    ├── 统计过去24小时的配额使用
    ├── 按小时聚合
    └── 存储到 quota_data 表
    ↓
用于仪表板展示
    ├── 配额使用趋势图
    ├── 请求量趋势图
    └── 成本分析
```

### 3. 渠道健康检查

```
定期任务 (可配置)
    ↓
AutomaticallyTestChannels()
    ├── 遍历所有启用的渠道
    ├── 并发测试每个渠道
    │   ├── 发送测试请求
    │   ├── 记录响应时间
    │   └── 检查响应状态
    ├── 更新渠道状态
    │   ├── 成功: 更新 test_time, response_time
    │   └── 失败: 可能自动禁用
    └── 记录测试结果
```

## 订阅系统工作流程

### 1. 订阅购买流程

```
用户选择订阅计划
    ↓
创建订阅订单
    ├── 订单状态: pending
    ├── 金额: plan.price_amount
    └── 支付方式: stripe/creem/...
    ↓
跳转到支付网关
    ↓
支付成功回调
    ↓
更新订单状态
    ├── 订单状态: paid
    └── 支付时间: now
    ↓
创建用户订阅
    ├── 状态: active
    ├── 开始时间: now
    ├── 结束时间: now + duration
    ├── 总配额: plan.total_amount
    ├── 剩余配额: plan.total_amount
    └── 配额重置周期: plan.quota_reset_period
    ↓
发送确认邮件
```

### 2. 配额重置流程

```
定期任务 (每小时检查)
    ↓
StartSubscriptionQuotaResetTask()
    ↓
查询需要重置的订阅
    ├── 状态: active
    ├── next_reset_time <= now
    └── quota_reset_period != "never"
    ↓
遍历每个订阅
    ├── 重置配额
    │   └── remaining_amount = total_amount
    ├── 更新重置时间
    │   ├── last_reset_time = now
    │   └── next_reset_time = now + reset_period
    └── 记录重置日志
```

## 多Key管理

### 1. 多Key模式

```
渠道配置多个Key
    ├── 轮询模式 (Polling)
    │   └── 按顺序使用每个Key
    └── 随机模式 (Random)
        └── 随机选择一个Key
```

### 2. Key状态管理

```
每个Key有独立状态
    ├── 启用 (1)
    ├── 禁用 (2)
    └── 自动禁用 (3)
    ↓
GetNextEnabledKey()
    ├── 过滤禁用的Key
    ├── 根据模式选择Key
    │   ├── 轮询: 使用 polling_index
    │   └── 随机: 随机选择
    └── 返回 Key 和索引
    ↓
如果Key失败
    ├── 标记该Key为禁用
    ├── 记录禁用原因
    ├── 记录禁用时间
    └── 下次请求使用其他Key
```

## 安全机制

### 1. 认证流程

```
客户端请求
    ↓
提取 Authorization 头
    ├── Bearer {token}
    └── 或 {token}
    ↓
查询令牌
    ├── 从数据库查询
    └── 检查缓存
    ↓
验证令牌
    ├── 令牌存在?
    ├── 令牌启用?
    ├── 令牌未过期?
    ├── IP在白名单? (如果配置)
    └── 配额充足? (如果不是无限配额)
    ↓
加载用户信息
    ├── 用户存在?
    ├── 用户启用?
    └── 用户配额充足?
    ↓
设置上下文
    ├── user_id
    ├── token_id
    ├── user_group
    └── token_group
```

### 2. 速率限制

```
全局速率限制
    ├── 限制: 每秒请求数
    └── 使用 Redis 计数器
    ↓
用户级速率限制
    ├── 限制: 每用户每分钟请求数
    └── 使用 Redis 计数器
    ↓
模型级速率限制
    ├── 限制: 每模型每分钟请求数
    └── 使用 Redis 计数器
    ↓
如果超限
    └── 返回 429 Too Many Requests
```

### 3. IP白名单

```
如果令牌配置了IP白名单
    ↓
提取客户端IP
    ├── X-Forwarded-For 头
    ├── X-Real-IP 头
    └── RemoteAddr
    ↓
检查IP是否在白名单
    ├── 支持单个IP: 1.2.3.4
    ├── 支持CIDR: 1.2.3.0/24
    └── 支持通配符: 1.2.3.*
    ↓
如果不在白名单
    └── 返回 403 Forbidden
```

## 性能优化策略

### 1. 数据库优化

```
连接池配置
    ├── MaxIdleConns: 100
    ├── MaxOpenConns: 1000
    └── ConnMaxLifetime: 60s
    ↓
索引优化
    ├── 用户名、邮箱索引
    ├── 令牌Key索引
    ├── 日志时间索引
    └── 渠道名称、标签索引
    ↓
批量更新 (可选)
    ├── 累积多个更新
    ├── 定期批量写入
    └── 减少数据库压力
```

### 2. 缓存优化

```
内存缓存
    ├── 渠道配置缓存
    ├── 系统配置缓存
    └── 定期同步
    ↓
Redis缓存 (可选)
    ├── 渠道亲和性
    ├── 速率限制计数
    └── 分布式锁
    ↓
磁盘缓存
    ├── 文件上传缓存
    └── 定期清理
```

### 3. 并发优化

```
使用 gopool
    ├── 渠道测试并发执行
    ├── 后台任务并发处理
    └── 避免阻塞主流程
    ↓
HTTP连接池
    ├── MaxIdleConns: 100
    ├── MaxIdleConnsPerHost: 20
    └── 复用连接
```

## 总结

New API 通过以下核心机制实现高效的 AI API 网关功能：

1. **统一接口**: 提供 OpenAI 兼容的统一 API 接口
2. **智能分发**: 基于权重、优先级、亲和性的智能渠道选择
3. **格式转换**: 自动转换不同提供商的 API 格式
4. **计费管理**: 精确的 Token 计数和配额管理
5. **错误处理**: 自动重试和渠道故障转移
6. **性能优化**: 多级缓存和连接池优化
7. **监控日志**: 完整的请求日志和监控统计
8. **安全控制**: 多层认证、授权和速率限制

这些机制协同工作，为用户提供稳定、高效、易用的 AI API 网关服务。
